// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace extensions {
    export namespace v1alpha1 {
        /**
         * Extend the functionality provided by the Istio proxy through WebAssembly filters. See more details at: https://istio.io/docs/reference/config/proxy_extensions/wasm-plugin.html
         */
        export interface WasmPluginSpecArgs {
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Credentials to use for OCI image pulling.
             */
            imagePullSecret?: pulumi.Input<string>;
            /**
             * Specifies the criteria to determine which traffic is passed to WasmPlugin.
             */
            match?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecMatchArgs>[]>;
            /**
             * Determines where in the filter chain this `WasmPlugin` is to be injected.
             */
            phase?: pulumi.Input<string>;
            /**
             * The configuration that will be passed on to the plugin.
             */
            pluginConfig?: pulumi.Input<{[key: string]: any}>;
            pluginName?: pulumi.Input<string>;
            /**
             * Determines ordering of `WasmPlugins` in the same `phase`.
             */
            priority?: pulumi.Input<number>;
            selector?: pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecSelectorArgs>;
            /**
             * SHA256 checksum that will be used to verify Wasm module or OCI container.
             */
            sha256?: pulumi.Input<string>;
            /**
             * URL of a Wasm module or OCI container.
             */
            url?: pulumi.Input<string>;
            verificationKey?: pulumi.Input<string>;
            /**
             * Configuration for a Wasm VM.
             */
            vmConfig?: pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecVmconfigArgs>;
        }

        export interface WasmPluginSpecMatchArgs {
            /**
             * Criteria for selecting traffic by their direction.
             */
            mode?: pulumi.Input<string>;
            /**
             * Criteria for selecting traffic by their destination port.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecMatchPortsArgs>[]>;
        }

        export interface WasmPluginSpecMatchPortsArgs {
            number?: pulumi.Input<number>;
        }

        export interface WasmPluginSpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration for a Wasm VM.
         */
        export interface WasmPluginSpecVmconfigArgs {
            /**
             * Specifies environment variables to be injected to this VM.
             */
            env?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecVmconfigEnvArgs>[]>;
        }

        export interface WasmPluginSpecVmconfigEnvArgs {
            name?: pulumi.Input<string>;
            /**
             * Value for the environment variable.
             */
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<string>;
        }
    }
}

export namespace networking {
    export namespace v1alpha3 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpecArgs {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            subsets?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsArgs>[]>;
            trafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyArgs>;
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecWorkloadselectorArgs>;
        }

        export interface DestinationRuleSpecSubsetsArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Name of the subset.
             */
            name?: pulumi.Input<string>;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyArgs>;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyOutlierdetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyTlsArgs>;
            tunnel?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetectionArgs>;
            port?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTlsArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: pulumi.Input<number>;
        }

        export interface DestinationRuleSpecTrafficpolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyOutlierdetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyTlsArgs>;
            tunnel?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecTrafficpolicyConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficpolicyOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetectionArgs>;
            port?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsTlsArgs>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface DestinationRuleSpecTrafficpolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: pulumi.Input<number>;
        }

        export interface DestinationRuleSpecWorkloadselectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
         */
        export interface EnvoyFilterSpecArgs {
            /**
             * One or more patches with match conditions.
             */
            configPatches?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecConfigpatchesArgs>[]>;
            /**
             * Priority defines the order in which patch sets are applied within a context.
             */
            priority?: pulumi.Input<number>;
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecWorkloadselectorArgs>;
        }

        export interface EnvoyFilterSpecConfigpatchesArgs {
            applyTo?: pulumi.Input<string>;
            /**
             * Match on listener/route configuration/cluster.
             */
            match?: any;
            /**
             * The patch to apply along with the operation.
             */
            patch?: pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecConfigpatchesPatchArgs>;
        }

        /**
         * The patch to apply along with the operation.
         */
        export interface EnvoyFilterSpecConfigpatchesPatchArgs {
            /**
             * Determines the filter insertion order.
             */
            filterClass?: pulumi.Input<string>;
            /**
             * Determines how the patch should be applied.
             */
            operation?: pulumi.Input<string>;
            /**
             * The JSON config of the object being patched.
             */
            value?: pulumi.Input<{[key: string]: any}>;
        }

        export interface EnvoyFilterSpecWorkloadselectorArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpecArgs {
            selector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * A list of server specifications.
             */
            servers?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersArgs>[]>;
        }

        export interface GatewaySpecServersArgs {
            bind?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: pulumi.Input<string>;
            port?: pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersPortArgs>;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersTlsArgs>;
        }

        export interface GatewaySpecServersPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            credentialName?: pulumi.Input<string>;
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpecArgs {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecEndpointsArgs>[]>;
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            location?: pulumi.Input<string>;
            /**
             * The ports associated with the external service.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecPortsArgs>[]>;
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecWorkloadselectorArgs>;
        }

        export interface ServiceEntrySpecEndpointsArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        export interface ServiceEntrySpecPortsArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadselectorArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpecArgs {
            egress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.SidecarSpecEgressArgs>[]>;
            ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressArgs>[]>;
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicyArgs>;
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecWorkloadselectorArgs>;
        }

        export interface SidecarSpecEgressArgs {
            bind?: pulumi.Input<string>;
            captureMode?: pulumi.Input<string>;
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecEgressPortArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        export interface SidecarSpecIngressArgs {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: pulumi.Input<string>;
            captureMode?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressPortArgs>;
            tls?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressTlsArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        export interface SidecarSpecIngressTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            credentialName?: pulumi.Input<string>;
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundtrafficpolicyArgs {
            egressProxy?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicyEgressproxyArgs>;
            mode?: pulumi.Input<string>;
        }

        export interface SidecarSpecOutboundtrafficpolicyEgressproxyArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicyEgressproxyPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundtrafficpolicyEgressproxyPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface SidecarSpecWorkloadselectorArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpecArgs {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpArgs>[]>;
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpArgs>[]>;
            tls?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsArgs>[]>;
        }

        export interface VirtualServiceSpecHttpArgs {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpCorspolicyArgs>;
            delegate?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpDelegateArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpDirectresponseArgs>;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpFaultArgs>;
            headers?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersArgs>;
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMatchArgs>[]>;
            mirror?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercent?: pulumi.Input<number>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorpercentageArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirror_percent?: pulumi.Input<number>;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: pulumi.Input<string>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRetriesArgs>;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRewriteArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteArgs>[]>;
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: pulumi.Input<string>;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorspolicyArgs {
            allowCredentials?: pulumi.Input<boolean>;
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The list of origins that are allowed to perform CORS requests.
             */
            allowOrigin?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: pulumi.Input<any[]>;
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            maxAge?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpDelegateArgs {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectresponseArgs {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status?: pulumi.Input<number>;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFaultArgs {
            abort?: any;
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpMatchArgs {
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            headers?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: pulumi.Input<boolean>;
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: pulumi.Input<string>;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * Query parameters for matching.
             */
            queryParams?: pulumi.Input<{[key: string]: any}>;
            scheme?: any;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: pulumi.Input<string>;
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: pulumi.Input<{[key: string]: any}>;
        }

        export interface VirtualServiceSpecHttpMirrorArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorpercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetriesArgs {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: pulumi.Input<number>;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: pulumi.Input<string>;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: pulumi.Input<string>;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: pulumi.Input<boolean>;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewriteArgs {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: pulumi.Input<string>;
            uri?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationArgs>;
            headers?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecTcpArgs {
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTcpMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * IPv4 or IPv6 ip address of source with optional subnet.
             */
            sourceSubnet?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTcpRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTcpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsArgs {
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTlsMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts?: pulumi.Input<pulumi.Input<string>[]>;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTlsRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpecArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
         */
        export interface WorkloadGroupSpecArgs {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: pulumi.Input<inputs.networking.v1alpha3.WorkloadGroupSpecMetadataArgs>;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template?: pulumi.Input<inputs.networking.v1alpha3.WorkloadGroupSpecTemplateArgs>;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadataArgs {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplateArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

    }

    export namespace v1beta1 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpecArgs {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            subsets?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsArgs>[]>;
            trafficPolicy?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyArgs>;
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecWorkloadselectorArgs>;
        }

        export interface DestinationRuleSpecSubsetsArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Name of the subset.
             */
            name?: pulumi.Input<string>;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyArgs>;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyOutlierdetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyTlsArgs>;
            tunnel?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetectionArgs>;
            port?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTlsArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: pulumi.Input<number>;
        }

        export interface DestinationRuleSpecTrafficpolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyOutlierdetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyTlsArgs>;
            tunnel?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecTrafficpolicyConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficpolicyOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetectionArgs>;
            port?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsTlsArgs>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            probes?: pulumi.Input<number>;
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            maxEjectionPercent?: pulumi.Input<number>;
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyTlsArgs {
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            credentialName?: pulumi.Input<string>;
            insecureSkipVerify?: pulumi.Input<boolean>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface DestinationRuleSpecTrafficpolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: pulumi.Input<number>;
        }

        export interface DestinationRuleSpecWorkloadselectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpecArgs {
            selector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * A list of server specifications.
             */
            servers?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersArgs>[]>;
        }

        export interface GatewaySpecServersArgs {
            bind?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: pulumi.Input<string>;
            port?: pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersPortArgs>;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersTlsArgs>;
        }

        export interface GatewaySpecServersPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            credentialName?: pulumi.Input<string>;
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
         */
        export interface ProxyConfigSpecArgs {
            /**
             * The number of worker threads to run.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * Additional environment variables for the proxy.
             */
            environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Specifies the details of the proxy image.
             */
            image?: pulumi.Input<inputs.networking.v1beta1.ProxyConfigSpecImageArgs>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.networking.v1beta1.ProxyConfigSpecSelectorArgs>;
        }

        /**
         * Specifies the details of the proxy image.
         */
        export interface ProxyConfigSpecImageArgs {
            /**
             * The image type of the image.
             */
            imageType?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface ProxyConfigSpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpecArgs {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecEndpointsArgs>[]>;
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            location?: pulumi.Input<string>;
            /**
             * The ports associated with the external service.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecPortsArgs>[]>;
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecWorkloadselectorArgs>;
        }

        export interface ServiceEntrySpecEndpointsArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        export interface ServiceEntrySpecPortsArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadselectorArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpecArgs {
            egress?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.SidecarSpecEgressArgs>[]>;
            ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressArgs>[]>;
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicyArgs>;
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecWorkloadselectorArgs>;
        }

        export interface SidecarSpecEgressArgs {
            bind?: pulumi.Input<string>;
            captureMode?: pulumi.Input<string>;
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecEgressPortArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        export interface SidecarSpecIngressArgs {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: pulumi.Input<string>;
            captureMode?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressPortArgs>;
            tls?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressTlsArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        export interface SidecarSpecIngressTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            credentialName?: pulumi.Input<string>;
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundtrafficpolicyArgs {
            egressProxy?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicyEgressproxyArgs>;
            mode?: pulumi.Input<string>;
        }

        export interface SidecarSpecOutboundtrafficpolicyEgressproxyArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicyEgressproxyPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundtrafficpolicyEgressproxyPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface SidecarSpecWorkloadselectorArgs {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpecArgs {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpArgs>[]>;
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpArgs>[]>;
            tls?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsArgs>[]>;
        }

        export interface VirtualServiceSpecHttpArgs {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpCorspolicyArgs>;
            delegate?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpDelegateArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpDirectresponseArgs>;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpFaultArgs>;
            headers?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersArgs>;
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMatchArgs>[]>;
            mirror?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercent?: pulumi.Input<number>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorpercentageArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirror_percent?: pulumi.Input<number>;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: pulumi.Input<string>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRetriesArgs>;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRewriteArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteArgs>[]>;
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: pulumi.Input<string>;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorspolicyArgs {
            allowCredentials?: pulumi.Input<boolean>;
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The list of origins that are allowed to perform CORS requests.
             */
            allowOrigin?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: pulumi.Input<any[]>;
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            maxAge?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpDelegateArgs {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectresponseArgs {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status?: pulumi.Input<number>;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFaultArgs {
            abort?: any;
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpMatchArgs {
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            headers?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: pulumi.Input<boolean>;
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: pulumi.Input<string>;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * Query parameters for matching.
             */
            queryParams?: pulumi.Input<{[key: string]: any}>;
            scheme?: any;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: pulumi.Input<string>;
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: pulumi.Input<{[key: string]: any}>;
        }

        export interface VirtualServiceSpecHttpMirrorArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorpercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetriesArgs {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: pulumi.Input<number>;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: pulumi.Input<string>;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: pulumi.Input<string>;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: pulumi.Input<boolean>;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewriteArgs {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: pulumi.Input<string>;
            uri?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationArgs>;
            headers?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecTcpArgs {
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTcpMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * IPv4 or IPv6 ip address of source with optional subnet.
             */
            sourceSubnet?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTcpRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTcpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsArgs {
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTlsMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts?: pulumi.Input<pulumi.Input<string>[]>;
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTlsRouteArgs {
            destination?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host?: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpecArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        export interface WorkloadGroupSpecArgs {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: pulumi.Input<inputs.networking.v1beta1.WorkloadGroupSpecMetadataArgs>;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template?: pulumi.Input<inputs.networking.v1beta1.WorkloadGroupSpecTemplateArgs>;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadataArgs {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplateArgs {
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

    }
}

export namespace security {
    export namespace v1 {
        /**
         * RequestAuthentication defines what request authentication methods are supported by a workload.
         */
        export interface RequestAuthenticationSpecArgs {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtrulesArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.security.v1.RequestAuthenticationSpecSelectorArgs>;
        }

        export interface RequestAuthenticationSpecJwtrulesArgs {
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: pulumi.Input<boolean>;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtrulesFromheadersArgs>[]>;
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer?: pulumi.Input<string>;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: pulumi.Input<string>;
            jwksUri?: pulumi.Input<string>;
            jwks_uri?: pulumi.Input<string>;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtrulesOutputclaimtoheadersArgs>[]>;
            outputPayloadToHeader?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtrulesFromheadersArgs {
            /**
             * The HTTP header name.
             */
            name?: pulumi.Input<string>;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtrulesOutputclaimtoheadersArgs {
            /**
             * The name of the claim to be copied from.
             */
            claim?: pulumi.Input<string>;
            /**
             * The name of the header to be created.
             */
            header?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

    }

    export namespace v1beta1 {
        /**
         * PeerAuthentication defines how traffic will be tunneled (or not) to the sidecar.
         */
        export interface PeerAuthenticationSpecArgs {
            /**
             * Mutual TLS settings for workload.
             */
            mtls?: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecMtlsArgs>;
            /**
             * Port specific mutual TLS settings.
             */
            portLevelMtls?: pulumi.Input<{[key: string]: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecPortlevelmtlsArgs>}>;
            /**
             * The selector determines the workloads to apply the ChannelAuthentication on.
             */
            selector?: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecSelectorArgs>;
        }

        /**
         * Mutual TLS settings for workload.
         */
        export interface PeerAuthenticationSpecMtlsArgs {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: pulumi.Input<string>;
        }

        export interface PeerAuthenticationSpecPortlevelmtlsArgs {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * The selector determines the workloads to apply the ChannelAuthentication on.
         */
        export interface PeerAuthenticationSpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * RequestAuthentication defines what request authentication methods are supported by a workload.
         */
        export interface RequestAuthenticationSpecArgs {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtrulesArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecSelectorArgs>;
        }

        export interface RequestAuthenticationSpecJwtrulesArgs {
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: pulumi.Input<boolean>;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtrulesFromheadersArgs>[]>;
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer?: pulumi.Input<string>;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: pulumi.Input<string>;
            jwksUri?: pulumi.Input<string>;
            jwks_uri?: pulumi.Input<string>;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtrulesOutputclaimtoheadersArgs>[]>;
            outputPayloadToHeader?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtrulesFromheadersArgs {
            /**
             * The HTTP header name.
             */
            name?: pulumi.Input<string>;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtrulesOutputclaimtoheadersArgs {
            /**
             * The name of the claim to be copied from.
             */
            claim?: pulumi.Input<string>;
            /**
             * The name of the header to be created.
             */
            header?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

    }
}

export namespace telemetry {
    export namespace v1alpha1 {
        /**
         * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
         */
        export interface TelemetrySpecArgs {
            /**
             * Optional.
             */
            accessLogging?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessloggingArgs>[]>;
            /**
             * Optional.
             */
            metrics?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecSelectorArgs>;
            /**
             * Optional.
             */
            tracing?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingArgs>[]>;
        }

        export interface TelemetrySpecAccessloggingArgs {
            /**
             * Controls logging.
             */
            disabled?: pulumi.Input<boolean>;
            /**
             * Optional.
             */
            filter?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessloggingFilterArgs>;
            /**
             * Allows tailoring of logging behavior to specific conditions.
             */
            match?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessloggingMatchArgs>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessloggingProvidersArgs>[]>;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecAccessloggingFilterArgs {
            /**
             * CEL expression for selecting when requests/connections should be logged.
             */
            expression?: pulumi.Input<string>;
        }

        /**
         * Allows tailoring of logging behavior to specific conditions.
         */
        export interface TelemetrySpecAccessloggingMatchArgs {
            mode?: pulumi.Input<string>;
        }

        export interface TelemetrySpecAccessloggingProvidersArgs {
            /**
             * Required.
             */
            name?: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsArgs {
            /**
             * Optional.
             */
            overrides?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesArgs>[]>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsProvidersArgs>[]>;
            /**
             * Optional.
             */
            reportingInterval?: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsOverridesArgs {
            /**
             * Optional.
             */
            disabled?: pulumi.Input<boolean>;
            /**
             * Match allows provides the scope of the override.
             */
            match?: any;
            /**
             * Optional.
             */
            tagOverrides?: pulumi.Input<{[key: string]: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesTagoverridesArgs>}>;
        }

        export interface TelemetrySpecMetricsOverridesTagoverridesArgs {
            /**
             * Operation controls whether or not to update/add a tag, or to remove it.
             */
            operation?: pulumi.Input<string>;
            /**
             * Value is only considered if the operation is `UPSERT`.
             */
            value?: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsProvidersArgs {
            /**
             * Required.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecSelectorArgs {
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface TelemetrySpecTracingArgs {
            /**
             * Optional.
             */
            customTags?: pulumi.Input<{[key: string]: any}>;
            /**
             * Controls span reporting.
             */
            disableSpanReporting?: pulumi.Input<boolean>;
            /**
             * Allows tailoring of behavior to specific conditions.
             */
            match?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingMatchArgs>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingProvidersArgs>[]>;
            randomSamplingPercentage?: pulumi.Input<number>;
            useRequestIdForTraceSampling?: pulumi.Input<boolean>;
        }

        /**
         * Allows tailoring of behavior to specific conditions.
         */
        export interface TelemetrySpecTracingMatchArgs {
            mode?: pulumi.Input<string>;
        }

        export interface TelemetrySpecTracingProvidersArgs {
            /**
             * Required.
             */
            name?: pulumi.Input<string>;
        }
    }
}
