// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace extensions {
    export namespace v1alpha1 {
        /**
         * Extend the functionality provided by the Istio proxy through WebAssembly filters. See more details at: https://istio.io/docs/reference/config/proxy_extensions/wasm-plugin.html
         */
        export interface WasmPluginSpec {
            imagePullPolicy?: string;
            /**
             * Credentials to use for OCI image pulling.
             */
            imagePullSecret?: string;
            /**
             * Specifies the criteria to determine which traffic is passed to WasmPlugin.
             */
            match?: outputs.extensions.v1alpha1.WasmPluginSpecMatch[];
            /**
             * Determines where in the filter chain this `WasmPlugin` is to be injected.
             */
            phase?: string;
            /**
             * The configuration that will be passed on to the plugin.
             */
            pluginConfig?: {[key: string]: any};
            pluginName?: string;
            /**
             * Determines ordering of `WasmPlugins` in the same `phase`.
             */
            priority?: number;
            selector?: outputs.extensions.v1alpha1.WasmPluginSpecSelector;
            /**
             * SHA256 checksum that will be used to verify Wasm module or OCI container.
             */
            sha256?: string;
            /**
             * URL of a Wasm module or OCI container.
             */
            url?: string;
            verificationKey?: string;
            /**
             * Configuration for a Wasm VM.
             */
            vmConfig?: outputs.extensions.v1alpha1.WasmPluginSpecVmconfig;
        }

        export interface WasmPluginSpecMatch {
            /**
             * Criteria for selecting traffic by their direction.
             */
            mode?: string;
            /**
             * Criteria for selecting traffic by their destination port.
             */
            ports?: outputs.extensions.v1alpha1.WasmPluginSpecMatchPorts[];
        }

        export interface WasmPluginSpecMatchPorts {
            number?: number;
        }

        export interface WasmPluginSpecSelector {
            matchLabels?: {[key: string]: string};
        }

        /**
         * Configuration for a Wasm VM.
         */
        export interface WasmPluginSpecVmconfig {
            /**
             * Specifies environment variables to be injected to this VM.
             */
            env?: outputs.extensions.v1alpha1.WasmPluginSpecVmconfigEnv[];
        }

        export interface WasmPluginSpecVmconfigEnv {
            name?: string;
            /**
             * Value for the environment variable.
             */
            value?: string;
            valueFrom?: string;
        }

    }
}

export namespace networking {
    export namespace v1alpha3 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpec {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: string[];
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            subsets?: outputs.networking.v1alpha3.DestinationRuleSpecSubsets[];
            trafficPolicy?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicy;
            workloadSelector?: outputs.networking.v1alpha3.DestinationRuleSpecWorkloadselector;
        }

        export interface DestinationRuleSpecSubsets {
            labels?: {[key: string]: string};
            /**
             * Name of the subset.
             */
            name?: string;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicy;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicy {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyOutlierdetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyTls;
            tunnel?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyTunnel;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettings {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetection;
            port?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTls;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: number;
        }

        export interface DestinationRuleSpecTrafficpolicy {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyOutlierdetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyTls;
            tunnel?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyTunnel;
        }

        export interface DestinationRuleSpecTrafficpolicyConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecTrafficpolicyOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettings {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetection;
            port?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsTls;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        export interface DestinationRuleSpecTrafficpolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: number;
        }

        export interface DestinationRuleSpecWorkloadselector {
            matchLabels?: {[key: string]: string};
        }

        /**
         * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
         */
        export interface EnvoyFilterSpec {
            /**
             * One or more patches with match conditions.
             */
            configPatches?: outputs.networking.v1alpha3.EnvoyFilterSpecConfigpatches[];
            /**
             * Priority defines the order in which patch sets are applied within a context.
             */
            priority?: number;
            workloadSelector?: outputs.networking.v1alpha3.EnvoyFilterSpecWorkloadselector;
        }

        export interface EnvoyFilterSpecConfigpatches {
            applyTo?: string;
            /**
             * Match on listener/route configuration/cluster.
             */
            match?: any;
            /**
             * The patch to apply along with the operation.
             */
            patch?: outputs.networking.v1alpha3.EnvoyFilterSpecConfigpatchesPatch;
        }

        /**
         * The patch to apply along with the operation.
         */
        export interface EnvoyFilterSpecConfigpatchesPatch {
            /**
             * Determines the filter insertion order.
             */
            filterClass?: string;
            /**
             * Determines how the patch should be applied.
             */
            operation?: string;
            /**
             * The JSON config of the object being patched.
             */
            value?: {[key: string]: any};
        }

        export interface EnvoyFilterSpecWorkloadselector {
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpec {
            selector?: {[key: string]: string};
            /**
             * A list of server specifications.
             */
            servers?: outputs.networking.v1alpha3.GatewaySpecServers[];
        }

        export interface GatewaySpecServers {
            bind?: string;
            defaultEndpoint?: string;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts?: string[];
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: string;
            port?: outputs.networking.v1alpha3.GatewaySpecServersPort;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: outputs.networking.v1alpha3.GatewaySpecServersTls;
        }

        export interface GatewaySpecServersPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTls {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            credentialName?: string;
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            subjectAltNames?: string[];
            verifyCertificateHash?: string[];
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpec {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: string[];
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: outputs.networking.v1alpha3.ServiceEntrySpecEndpoints[];
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: string[];
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts?: string[];
            location?: string;
            /**
             * The ports associated with the external service.
             */
            ports?: outputs.networking.v1alpha3.ServiceEntrySpecPorts[];
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: string;
            subjectAltNames?: string[];
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: outputs.networking.v1alpha3.ServiceEntrySpecWorkloadselector;
        }

        export interface ServiceEntrySpecEndpoints {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        export interface ServiceEntrySpecPorts {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadselector {
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpec {
            egress?: outputs.networking.v1alpha3.SidecarSpecEgress[];
            ingress?: outputs.networking.v1alpha3.SidecarSpecIngress[];
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: outputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicy;
            workloadSelector?: outputs.networking.v1alpha3.SidecarSpecWorkloadselector;
        }

        export interface SidecarSpecEgress {
            bind?: string;
            captureMode?: string;
            hosts?: string[];
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1alpha3.SidecarSpecEgressPort;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        export interface SidecarSpecIngress {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: string;
            captureMode?: string;
            defaultEndpoint?: string;
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1alpha3.SidecarSpecIngressPort;
            tls?: outputs.networking.v1alpha3.SidecarSpecIngressTls;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        export interface SidecarSpecIngressTls {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            credentialName?: string;
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            subjectAltNames?: string[];
            verifyCertificateHash?: string[];
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundtrafficpolicy {
            egressProxy?: outputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicyEgressproxy;
            mode?: string;
        }

        export interface SidecarSpecOutboundtrafficpolicyEgressproxy {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.SidecarSpecOutboundtrafficpolicyEgressproxyPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundtrafficpolicyEgressproxyPort {
            number?: number;
        }

        export interface SidecarSpecWorkloadselector {
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpec {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: string[];
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: string[];
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: string[];
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: outputs.networking.v1alpha3.VirtualServiceSpecHttp[];
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: outputs.networking.v1alpha3.VirtualServiceSpecTcp[];
            tls?: outputs.networking.v1alpha3.VirtualServiceSpecTls[];
        }

        export interface VirtualServiceSpecHttp {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: outputs.networking.v1alpha3.VirtualServiceSpecHttpCorspolicy;
            delegate?: outputs.networking.v1alpha3.VirtualServiceSpecHttpDelegate;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: outputs.networking.v1alpha3.VirtualServiceSpecHttpDirectresponse;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: outputs.networking.v1alpha3.VirtualServiceSpecHttpFault;
            headers?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeaders;
            match?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMatch[];
            mirror?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirror;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercent?: number;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorpercentage;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirror_percent?: number;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: string;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRetries;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRewrite;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRoute[];
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: string;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorspolicy {
            allowCredentials?: boolean;
            allowHeaders?: string[];
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: string[];
            /**
             * The list of origins that are allowed to perform CORS requests.
             */
            allowOrigin?: string[];
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: any[];
            exposeHeaders?: string[];
            maxAge?: string;
        }

        export interface VirtualServiceSpecHttpDelegate {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: string;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: string;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectresponse {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status?: number;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFault {
            abort?: any;
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeaders {
            request?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersRequest;
            response?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersResponse;
        }

        export interface VirtualServiceSpecHttpHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpMatch {
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            headers?: {[key: string]: any};
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: boolean;
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: string;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: number;
            /**
             * Query parameters for matching.
             */
            queryParams?: {[key: string]: any};
            scheme?: any;
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: string;
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: {[key: string]: any};
        }

        export interface VirtualServiceSpecHttpMirror {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPort {
            number?: number;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorpercentage {
            value?: number;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetries {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: number;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: string;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: string;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: boolean;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewrite {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: string;
            uri?: string;
        }

        export interface VirtualServiceSpecHttpRoute {
            destination?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestination;
            headers?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeaders;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecHttpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpRouteHeaders {
            request?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersRequest;
            response?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersResponse;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecTcp {
            match?: outputs.networking.v1alpha3.VirtualServiceSpecTcpMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecTcpRoute[];
        }

        export interface VirtualServiceSpecTcpMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * IPv4 or IPv6 ip address of source with optional subnet.
             */
            sourceSubnet?: string;
        }

        export interface VirtualServiceSpecTcpRoute {
            destination?: outputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecTcpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecTls {
            match?: outputs.networking.v1alpha3.VirtualServiceSpecTlsMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecTlsRoute[];
        }

        export interface VirtualServiceSpecTlsMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts?: string[];
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
        }

        export interface VirtualServiceSpecTlsRoute {
            destination?: outputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecTlsRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPort {
            number?: number;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpec {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        /**
         * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
         */
        export interface WorkloadGroupSpec {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: outputs.networking.v1alpha3.WorkloadGroupSpecMetadata;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template?: outputs.networking.v1alpha3.WorkloadGroupSpecTemplate;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadata {
            annotations?: {[key: string]: string};
            labels?: {[key: string]: string};
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplate {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

    }

    export namespace v1beta1 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpec {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: string[];
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            subsets?: outputs.networking.v1beta1.DestinationRuleSpecSubsets[];
            trafficPolicy?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicy;
            workloadSelector?: outputs.networking.v1beta1.DestinationRuleSpecWorkloadselector;
        }

        export interface DestinationRuleSpecSubsets {
            labels?: {[key: string]: string};
            /**
             * Name of the subset.
             */
            name?: string;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicy;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicy {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyOutlierdetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyTls;
            tunnel?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyTunnel;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettings {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetection;
            port?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTls;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyPortlevelsettingsTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficpolicyTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        export interface DestinationRuleSpecSubsetsTrafficpolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: number;
        }

        export interface DestinationRuleSpecTrafficpolicy {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyOutlierdetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyTls;
            tunnel?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyTunnel;
        }

        export interface DestinationRuleSpecTrafficpolicyConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecTrafficpolicyOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettings {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetection;
            port?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsTls;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsConnectionpoolTcpTcpkeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            probes?: number;
            time?: string;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsOutlierdetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            maxEjectionPercent?: number;
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyPortlevelsettingsTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficpolicyTls {
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            credentialName?: string;
            insecureSkipVerify?: boolean;
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            subjectAltNames?: string[];
        }

        export interface DestinationRuleSpecTrafficpolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost?: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort?: number;
        }

        export interface DestinationRuleSpecWorkloadselector {
            matchLabels?: {[key: string]: string};
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpec {
            selector?: {[key: string]: string};
            /**
             * A list of server specifications.
             */
            servers?: outputs.networking.v1beta1.GatewaySpecServers[];
        }

        export interface GatewaySpecServers {
            bind?: string;
            defaultEndpoint?: string;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts?: string[];
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: string;
            port?: outputs.networking.v1beta1.GatewaySpecServersPort;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: outputs.networking.v1beta1.GatewaySpecServersTls;
        }

        export interface GatewaySpecServersPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTls {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            credentialName?: string;
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            subjectAltNames?: string[];
            verifyCertificateHash?: string[];
            verifyCertificateSpki?: string[];
        }

        /**
         * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
         */
        export interface ProxyConfigSpec {
            /**
             * The number of worker threads to run.
             */
            concurrency?: number;
            /**
             * Additional environment variables for the proxy.
             */
            environmentVariables?: {[key: string]: string};
            /**
             * Specifies the details of the proxy image.
             */
            image?: outputs.networking.v1beta1.ProxyConfigSpecImage;
            /**
             * Optional.
             */
            selector?: outputs.networking.v1beta1.ProxyConfigSpecSelector;
        }

        /**
         * Specifies the details of the proxy image.
         */
        export interface ProxyConfigSpecImage {
            /**
             * The image type of the image.
             */
            imageType?: string;
        }

        /**
         * Optional.
         */
        export interface ProxyConfigSpecSelector {
            matchLabels?: {[key: string]: string};
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpec {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: string[];
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: outputs.networking.v1beta1.ServiceEntrySpecEndpoints[];
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: string[];
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts?: string[];
            location?: string;
            /**
             * The ports associated with the external service.
             */
            ports?: outputs.networking.v1beta1.ServiceEntrySpecPorts[];
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: string;
            subjectAltNames?: string[];
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: outputs.networking.v1beta1.ServiceEntrySpecWorkloadselector;
        }

        export interface ServiceEntrySpecEndpoints {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        export interface ServiceEntrySpecPorts {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadselector {
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpec {
            egress?: outputs.networking.v1beta1.SidecarSpecEgress[];
            ingress?: outputs.networking.v1beta1.SidecarSpecIngress[];
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: outputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicy;
            workloadSelector?: outputs.networking.v1beta1.SidecarSpecWorkloadselector;
        }

        export interface SidecarSpecEgress {
            bind?: string;
            captureMode?: string;
            hosts?: string[];
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1beta1.SidecarSpecEgressPort;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        export interface SidecarSpecIngress {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: string;
            captureMode?: string;
            defaultEndpoint?: string;
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1beta1.SidecarSpecIngressPort;
            tls?: outputs.networking.v1beta1.SidecarSpecIngressTls;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        export interface SidecarSpecIngressTls {
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            credentialName?: string;
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            subjectAltNames?: string[];
            verifyCertificateHash?: string[];
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundtrafficpolicy {
            egressProxy?: outputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicyEgressproxy;
            mode?: string;
        }

        export interface SidecarSpecOutboundtrafficpolicyEgressproxy {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.SidecarSpecOutboundtrafficpolicyEgressproxyPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundtrafficpolicyEgressproxyPort {
            number?: number;
        }

        export interface SidecarSpecWorkloadselector {
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpec {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: string[];
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: string[];
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: string[];
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: outputs.networking.v1beta1.VirtualServiceSpecHttp[];
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: outputs.networking.v1beta1.VirtualServiceSpecTcp[];
            tls?: outputs.networking.v1beta1.VirtualServiceSpecTls[];
        }

        export interface VirtualServiceSpecHttp {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: outputs.networking.v1beta1.VirtualServiceSpecHttpCorspolicy;
            delegate?: outputs.networking.v1beta1.VirtualServiceSpecHttpDelegate;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: outputs.networking.v1beta1.VirtualServiceSpecHttpDirectresponse;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: outputs.networking.v1beta1.VirtualServiceSpecHttpFault;
            headers?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeaders;
            match?: outputs.networking.v1beta1.VirtualServiceSpecHttpMatch[];
            mirror?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirror;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercent?: number;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorpercentage;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirror_percent?: number;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: string;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: outputs.networking.v1beta1.VirtualServiceSpecHttpRetries;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: outputs.networking.v1beta1.VirtualServiceSpecHttpRewrite;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecHttpRoute[];
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: string;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorspolicy {
            allowCredentials?: boolean;
            allowHeaders?: string[];
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: string[];
            /**
             * The list of origins that are allowed to perform CORS requests.
             */
            allowOrigin?: string[];
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: any[];
            exposeHeaders?: string[];
            maxAge?: string;
        }

        export interface VirtualServiceSpecHttpDelegate {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: string;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: string;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectresponse {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status?: number;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFault {
            abort?: any;
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeaders {
            request?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeadersRequest;
            response?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeadersResponse;
        }

        export interface VirtualServiceSpecHttpHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpMatch {
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            headers?: {[key: string]: any};
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: boolean;
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: string;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: number;
            /**
             * Query parameters for matching.
             */
            queryParams?: {[key: string]: any};
            scheme?: any;
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: string;
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: {[key: string]: any};
        }

        export interface VirtualServiceSpecHttpMirror {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPort {
            number?: number;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorpercentage {
            value?: number;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetries {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: number;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: string;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: string;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: boolean;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewrite {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: string;
            uri?: string;
        }

        export interface VirtualServiceSpecHttpRoute {
            destination?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestination;
            headers?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeaders;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecHttpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpRouteHeaders {
            request?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersRequest;
            response?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersResponse;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecTcp {
            match?: outputs.networking.v1beta1.VirtualServiceSpecTcpMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecTcpRoute[];
        }

        export interface VirtualServiceSpecTcpMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * IPv4 or IPv6 ip address of source with optional subnet.
             */
            sourceSubnet?: string;
        }

        export interface VirtualServiceSpecTcpRoute {
            destination?: outputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecTcpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecTls {
            match?: outputs.networking.v1beta1.VirtualServiceSpecTlsMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecTlsRoute[];
        }

        export interface VirtualServiceSpecTlsMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts?: string[];
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
        }

        export interface VirtualServiceSpecTlsRoute {
            destination?: outputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        export interface VirtualServiceSpecTlsRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host?: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPort {
            number?: number;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpec {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        export interface WorkloadGroupSpec {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: outputs.networking.v1beta1.WorkloadGroupSpecMetadata;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template?: outputs.networking.v1beta1.WorkloadGroupSpecTemplate;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadata {
            annotations?: {[key: string]: string};
            labels?: {[key: string]: string};
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplate {
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

    }
}

export namespace security {
    export namespace v1 {
        /**
         * RequestAuthentication defines what request authentication methods are supported by a workload.
         */
        export interface RequestAuthenticationSpec {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: outputs.security.v1.RequestAuthenticationSpecJwtrules[];
            /**
             * Optional.
             */
            selector?: outputs.security.v1.RequestAuthenticationSpecSelector;
        }

        export interface RequestAuthenticationSpecJwtrules {
            audiences?: string[];
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: boolean;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: outputs.security.v1.RequestAuthenticationSpecJwtrulesFromheaders[];
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: string[];
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer?: string;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: string;
            jwksUri?: string;
            jwks_uri?: string;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: outputs.security.v1.RequestAuthenticationSpecJwtrulesOutputclaimtoheaders[];
            outputPayloadToHeader?: string;
        }

        export interface RequestAuthenticationSpecJwtrulesFromheaders {
            /**
             * The HTTP header name.
             */
            name?: string;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: string;
        }

        export interface RequestAuthenticationSpecJwtrulesOutputclaimtoheaders {
            /**
             * The name of the claim to be copied from.
             */
            claim?: string;
            /**
             * The name of the header to be created.
             */
            header?: string;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelector {
            matchLabels?: {[key: string]: string};
        }

    }

    export namespace v1beta1 {
        /**
         * PeerAuthentication defines how traffic will be tunneled (or not) to the sidecar.
         */
        export interface PeerAuthenticationSpec {
            /**
             * Mutual TLS settings for workload.
             */
            mtls?: outputs.security.v1beta1.PeerAuthenticationSpecMtls;
            /**
             * Port specific mutual TLS settings.
             */
            portLevelMtls?: {[key: string]: outputs.security.v1beta1.PeerAuthenticationSpecPortlevelmtls};
            /**
             * The selector determines the workloads to apply the ChannelAuthentication on.
             */
            selector?: outputs.security.v1beta1.PeerAuthenticationSpecSelector;
        }

        /**
         * Mutual TLS settings for workload.
         */
        export interface PeerAuthenticationSpecMtls {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: string;
        }

        export interface PeerAuthenticationSpecPortlevelmtls {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: string;
        }

        /**
         * The selector determines the workloads to apply the ChannelAuthentication on.
         */
        export interface PeerAuthenticationSpecSelector {
            matchLabels?: {[key: string]: string};
        }

        /**
         * RequestAuthentication defines what request authentication methods are supported by a workload.
         */
        export interface RequestAuthenticationSpec {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: outputs.security.v1beta1.RequestAuthenticationSpecJwtrules[];
            /**
             * Optional.
             */
            selector?: outputs.security.v1beta1.RequestAuthenticationSpecSelector;
        }

        export interface RequestAuthenticationSpecJwtrules {
            audiences?: string[];
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: boolean;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: outputs.security.v1beta1.RequestAuthenticationSpecJwtrulesFromheaders[];
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: string[];
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer?: string;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: string;
            jwksUri?: string;
            jwks_uri?: string;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: outputs.security.v1beta1.RequestAuthenticationSpecJwtrulesOutputclaimtoheaders[];
            outputPayloadToHeader?: string;
        }

        export interface RequestAuthenticationSpecJwtrulesFromheaders {
            /**
             * The HTTP header name.
             */
            name?: string;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: string;
        }

        export interface RequestAuthenticationSpecJwtrulesOutputclaimtoheaders {
            /**
             * The name of the claim to be copied from.
             */
            claim?: string;
            /**
             * The name of the header to be created.
             */
            header?: string;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelector {
            matchLabels?: {[key: string]: string};
        }

    }
}

export namespace telemetry {
    export namespace v1alpha1 {
        /**
         * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
         */
        export interface TelemetrySpec {
            /**
             * Optional.
             */
            accessLogging?: outputs.telemetry.v1alpha1.TelemetrySpecAccesslogging[];
            /**
             * Optional.
             */
            metrics?: outputs.telemetry.v1alpha1.TelemetrySpecMetrics[];
            /**
             * Optional.
             */
            selector?: outputs.telemetry.v1alpha1.TelemetrySpecSelector;
            /**
             * Optional.
             */
            tracing?: outputs.telemetry.v1alpha1.TelemetrySpecTracing[];
        }

        export interface TelemetrySpecAccesslogging {
            /**
             * Controls logging.
             */
            disabled?: boolean;
            /**
             * Optional.
             */
            filter?: outputs.telemetry.v1alpha1.TelemetrySpecAccessloggingFilter;
            /**
             * Allows tailoring of logging behavior to specific conditions.
             */
            match?: outputs.telemetry.v1alpha1.TelemetrySpecAccessloggingMatch;
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecAccessloggingProviders[];
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecAccessloggingFilter {
            /**
             * CEL expression for selecting when requests/connections should be logged.
             */
            expression?: string;
        }

        /**
         * Allows tailoring of logging behavior to specific conditions.
         */
        export interface TelemetrySpecAccessloggingMatch {
            mode?: string;
        }

        export interface TelemetrySpecAccessloggingProviders {
            /**
             * Required.
             */
            name?: string;
        }

        export interface TelemetrySpecMetrics {
            /**
             * Optional.
             */
            overrides?: outputs.telemetry.v1alpha1.TelemetrySpecMetricsOverrides[];
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecMetricsProviders[];
            /**
             * Optional.
             */
            reportingInterval?: string;
        }

        export interface TelemetrySpecMetricsOverrides {
            /**
             * Optional.
             */
            disabled?: boolean;
            /**
             * Match allows provides the scope of the override.
             */
            match?: any;
            /**
             * Optional.
             */
            tagOverrides?: {[key: string]: outputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesTagoverrides};
        }

        export interface TelemetrySpecMetricsOverridesTagoverrides {
            /**
             * Operation controls whether or not to update/add a tag, or to remove it.
             */
            operation?: string;
            /**
             * Value is only considered if the operation is `UPSERT`.
             */
            value?: string;
        }

        export interface TelemetrySpecMetricsProviders {
            /**
             * Required.
             */
            name?: string;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecSelector {
            matchLabels?: {[key: string]: string};
        }

        export interface TelemetrySpecTracing {
            /**
             * Optional.
             */
            customTags?: {[key: string]: any};
            /**
             * Controls span reporting.
             */
            disableSpanReporting?: boolean;
            /**
             * Allows tailoring of behavior to specific conditions.
             */
            match?: outputs.telemetry.v1alpha1.TelemetrySpecTracingMatch;
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecTracingProviders[];
            randomSamplingPercentage?: number;
            useRequestIdForTraceSampling?: boolean;
        }

        /**
         * Allows tailoring of behavior to specific conditions.
         */
        export interface TelemetrySpecTracingMatch {
            mode?: string;
        }

        export interface TelemetrySpecTracingProviders {
            /**
             * Required.
             */
            name?: string;
        }

    }
}
